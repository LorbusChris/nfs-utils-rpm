diff --git a/support/include/conffile.h b/support/include/conffile.h
index 672020a..fe23ec2 100644
--- a/support/include/conffile.h
+++ b/support/include/conffile.h
@@ -75,4 +75,11 @@ static inline void upper2lower(char *str)
 	while ((c = tolower(*str)))
 		*str++ = c;
 }
+
+/*
+ * Default Mount options
+ */
+extern unsigned long config_default_vers;
+extern unsigned long config_default_proto;
+
 #endif				/* _CONFFILE_H_ */
diff --git a/utils/mount/configfile.c b/utils/mount/configfile.c
index e347b0e..28b722c 100644
--- a/utils/mount/configfile.c
+++ b/utils/mount/configfile.c
@@ -20,13 +20,19 @@
 #include <config.h>
 #endif
 #include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
+#include <errno.h>
 
 #include "xlog.h"
+#include "mount.h"
+#include "parse_opt.h"
+#include "network.h"
 #include "conffile.h"
 
 #define KBYTES(x)     ((x) * (1024))
@@ -185,6 +191,63 @@ void free_all(void)
 		free(entry);
 	}
 }
+static char *versions[] = {"v2", "v3", "v4", "vers", "nfsvers", NULL};
+int inline check_vers(char *mopt, char *field)
+{
+	int i;
+
+	if (strncmp("mountvers", field, strlen("mountvers")) != 0) {
+		for (i=0; versions[i]; i++) 
+			if (strcasestr(mopt, versions[i]) != NULL)
+				return 1;
+	}
+	return 0;
+}
+
+unsigned long config_default_vers;
+unsigned long config_default_proto;
+/*
+ * Check to see if a default value is being set.
+ * If so, set the appropriate global value which will 
+ * be used as the initial value in the server negation.
+ */
+int inline default_value(char *mopt)
+{
+	struct mount_options *options = NULL;
+	int dftlen = strlen("default");
+	char *field;
+
+	if (strncasecmp(mopt, "default", dftlen) != 0)
+		return 0;
+
+	field = mopt + dftlen;
+	if (strncasecmp(field, "proto", strlen("proto")) == 0) {
+		if ((options = po_split(field)) != NULL) {
+			if (!nfs_nfs_protocol(options, &config_default_proto)) {
+				xlog_warn("Unable to set default protocol : %s", 
+					strerror(errno));
+			}
+		} else {
+			xlog_warn("Unable to alloc memory for default protocol");
+		}
+	} else if (strncasecmp(field, "vers", strlen("vers")) == 0) {
+		if ((options = po_split(field)) != NULL) {
+			if (!nfs_nfs_version(options, &config_default_vers)) {
+				xlog_warn("Unable to set default version: %s", 
+					strerror(errno));
+				
+			}
+		} else {
+			xlog_warn("Unable to alloc memory for default version");
+		}
+	} else 
+		xlog_warn("Invalid default setting: '%s'", mopt);
+
+	if (options)
+		po_destroy(options);
+
+	return 1;
+}
 /*
  * Parse the given section of the configuration 
  * file to if there are any mount options set.
@@ -207,6 +270,12 @@ conf_parse_mntopts(char *section, char *arg, char *opts)
 		snprintf(buf, BUFSIZ, "%s=", node->field);
 		if (opts && strcasestr(opts, buf) != NULL)
 			continue;
+		/* 
+		 * Protocol verions can be set in a number of ways
+		 */
+		if (opts && check_vers(opts, node->field))
+			continue;
+
 		if (lookup_entry(node->field) != NULL)
 			continue;
 		buf[0] = '\0';
@@ -302,15 +371,19 @@ char *conf_get_mntopts(char *spec, char *mount_point,
 		free_all();
 		return mount_opts;
 	}
+
 	if (mount_opts) {
 		strcpy(config_opts, mount_opts);
 		strcat(config_opts, ",");
 	}
 	SLIST_FOREACH(entry, &head, entries) {
+		if (default_value(entry->opt))
+			continue;
 		strcat(config_opts, entry->opt);
 		strcat(config_opts, ",");
 	}
-	*(strrchr(config_opts, ',')) = '\0';
+	if ((ptr = strrchr(config_opts, ',')) != NULL)
+		*ptr = '\0';
 
 	free_all();
 	if (mount_opts)
diff --git a/utils/mount/network.c b/utils/mount/network.c
index bd621be..e651167 100644
--- a/utils/mount/network.c
+++ b/utils/mount/network.c
@@ -50,6 +50,7 @@
 #include "nfsrpc.h"
 #include "parse_opt.h"
 #include "network.h"
+#include "conffile.h"
 
 #define PMAP_TIMEOUT	(10)
 #define CONNECT_TIMEOUT	(20)
@@ -609,10 +610,19 @@ static int nfs_probe_nfsport(const struct sockaddr *sap, const socklen_t salen,
 	if (pmap->pm_vers && pmap->pm_prot && pmap->pm_port)
 		return 1;
 
-	if (nfs_mount_data_version >= 4)
+	if (nfs_mount_data_version >= 4) {
+		const unsigned int *probe_proto = probe_tcp_first;
+
+		/*
+		 * If the default proto has been set and 
+		 * its not TCP, start with UDP
+		 */
+		if (config_default_proto && config_default_proto != IPPROTO_TCP)
+			probe_proto =  probe_udp_first;
+
 		return nfs_probe_port(sap, salen, pmap,
-					probe_nfs3_first, probe_tcp_first);
-	else
+					probe_nfs3_first, probe_proto);
+	} else
 		return nfs_probe_port(sap, salen, pmap,
 					probe_nfs2_only, probe_udp_only);
 }
@@ -1261,7 +1271,7 @@ nfs_nfs_version(struct mount_options *options, unsigned long *version)
  * Returns TRUE if @protocol contains a valid value for this option,
  * or FALSE if the option was specified with an invalid value.
  */
-static int
+int
 nfs_nfs_protocol(struct mount_options *options, unsigned long *protocol)
 {
 	char *option;
diff --git a/utils/mount/network.h b/utils/mount/network.h
index 402e0a5..7eb89b0 100644
--- a/utils/mount/network.h
+++ b/utils/mount/network.h
@@ -57,6 +57,8 @@ int clnt_ping(struct sockaddr_in *, const unsigned long,
 struct mount_options;
 
 int nfs_nfs_version(struct mount_options *options, unsigned long *version);
+int  nfs_nfs_protocol(struct mount_options *options, unsigned long *protocol);
+
 int nfs_options2pmap(struct mount_options *,
 		      struct pmap *, struct pmap *);
 
diff --git a/utils/mount/nfsmount.conf b/utils/mount/nfsmount.conf
index f9fcfcb..9b8ff4a 100644
--- a/utils/mount/nfsmount.conf
+++ b/utils/mount/nfsmount.conf
@@ -24,14 +24,29 @@
 # All reads and writes to the 'nfsserver.foo.com' server 
 # will be done with 32k (32768 bytes) block sizes.
 #
-#[ NFSMount_Global_Options ]
+[ NFSMount_Global_Options ]
 # This statically named section defines global mount 
 # options that can be applied on all NFS mount.
 #
-# Protocol Version [2,3]
-# Nfsvers=3
-# Network Transport [Udp,Tcp,Rdma]
-# Proto=Tcp
+# Protocol Version [2,3,4]
+# This defines the default protocol version which will
+# be used to start the negotiation with the server.
+# Defaultvers=4
+#
+# Setting this option makes it mandatory the server supports the
+# given version. The mount will fail if the given version is 
+# not support by the server. 
+# Nfsvers=4
+#
+# Network Protocol [udp,tcp,rdma] (Note: values are case sensitive)
+# This defines the default network protocol which will
+# be used to start the negotiation with the server.
+# Defaultproto=tcp
+#
+# Setting this option makes it mandatory the server supports the
+# given network protocol. The mount will fail if the given network
+# protocol is not supported by the server.
+# Proto=tcp
 #
 # The number of times a request will be retired before 
 # generating a timeout 
diff --git a/utils/mount/stropts.c b/utils/mount/stropts.c
index 069bdc1..ceefdb0 100644
--- a/utils/mount/stropts.c
+++ b/utils/mount/stropts.c
@@ -45,6 +45,7 @@
 #include "parse_opt.h"
 #include "version.h"
 #include "parse_dev.h"
+#include "conffile.h"
 
 #ifndef NFS_PROGRAM
 #define NFS_PROGRAM	(100003)
@@ -283,6 +284,14 @@ static int nfs_validate_options(struct nfsmount_info *mi)
 		if (option && strcmp(option, "rdma") == 0)
 			mi->version = 3;
 	}
+	/*
+	 * Use the default value set in the config file when
+	 * the version has not been explicitly set.
+	 */
+	if (mi->version == 0 && config_default_vers) {
+		if (config_default_vers < 4)
+			mi->version = config_default_vers;
+	}
 
 	if (!nfs_append_sloppy_option(mi->options))
 		return 0;
