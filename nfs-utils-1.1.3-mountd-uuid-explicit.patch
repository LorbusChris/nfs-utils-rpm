commit 0ae97c5b87a56870e74a74ae50aeb2ae0e496907
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Thu Aug 28 10:29:54 2008 -0400

    Fix handling of explicit uuid
    
    Fix a couple of bugs which show up if you try to explicitly set a
    16-byte UUID when exporting a file system. First, exportfs cuts the
    first two bytes off the UUID and writes something invalid to etab.
    Second, mountd writes the _ascii_ form of the UUID to the kernel,
    instead of converting it to hex.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Signed-off-by: Steve Dickson <steved@redhat.com>

diff --git a/support/nfs/exports.c b/support/nfs/exports.c
index 525e5b1..334c08e 100644
--- a/support/nfs/exports.c
+++ b/support/nfs/exports.c
@@ -595,7 +595,7 @@ bad_option:
 				if (opt[5]!='\0' && *oe == '\0') 
 					ep->e_flags |= NFSEXP_FSID;
 				else if (valid_uuid(opt+5))
-					ep->e_uuid = strdup(opt+7);
+					ep->e_uuid = strdup(opt+5);
 				else {
 					xlog(L_ERROR, "%s: %d: bad fsid \"%s\"\n",
 					     flname, flline, opt);	
diff --git a/utils/mountd/cache.c b/utils/mountd/cache.c
index 609c6e3..2ebdd45 100644
--- a/utils/mountd/cache.c
+++ b/utils/mountd/cache.c
@@ -592,8 +592,10 @@ static int dump_to_cache(FILE *f, char *domain, char *path, struct exportent *ex
  				qword_printhex(f, u, 16);
  			}
  		} else {
+ 			char u[16];
+ 			get_uuid(NULL, exp->e_uuid, 16, u);
  			qword_print(f, "uuid");
- 			qword_printhex(f, exp->e_uuid, 16);
+ 			qword_printhex(f, u, 16);
  		}
 #endif
 	}
