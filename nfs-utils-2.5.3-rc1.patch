diff --git a/support/misc/nfsd_path.c b/support/misc/nfsd_path.c
index 8efbfcd..65e53c1 100644
--- a/support/misc/nfsd_path.c
+++ b/support/misc/nfsd_path.c
@@ -110,7 +110,7 @@ nfsd_setup_workqueue(void)
 
 	if (!rootdir)
 		return;
-printf("rootdir %s\n", rootdir);
+
 	nfsd_wq = xthread_workqueue_alloc();
 	if (!nfsd_wq)
 		return;
diff --git a/support/nfs/conffile.c b/support/nfs/conffile.c
index 3d13610..a4ea067 100644
--- a/support/nfs/conffile.c
+++ b/support/nfs/conffile.c
@@ -52,10 +52,14 @@
 #include <libgen.h>
 #include <sys/file.h>
 #include <time.h>
+#include <dirent.h>
 
 #include "conffile.h"
 #include "xlog.h"
 
+#define CONF_FILE_EXT ".conf"
+#define CONF_FILE_EXT_LEN ((int) (sizeof(CONF_FILE_EXT) - 1))
+
 #pragma GCC visibility push(hidden)
 
 static void conf_load_defaults(void);
@@ -456,7 +460,7 @@ conf_parse_line(int trans, char *line, const char *filename, int lineno, char **
 		free(subconf);
 	} else {
 		/* XXX Perhaps should we not ignore errors?  */
-		conf_set(trans, *section, *subsection, line, val, 0, 0);
+		conf_set(trans, *section, *subsection, line, val, 1, 0);
 	}
 }
 
@@ -577,6 +581,30 @@ static void conf_free_bindings(void)
 	}
 }
 
+static int
+conf_load_files(int trans, const char *conf_file)
+{
+	char *conf_data;
+	char *section = NULL;
+	char *subsection = NULL;
+
+	conf_data = conf_readfile(conf_file);
+	if (conf_data == NULL)
+		return 1;
+
+	/* Load default configuration values.  */
+	conf_load_defaults();
+
+	/* Parse config contents into the transaction queue */
+	conf_parse(trans, conf_data, &section, &subsection, conf_file);
+	if (section) 
+		free(section);
+	if (subsection) 
+		free(subsection);
+	free(conf_data);
+
+	return 0;
+}
 /* Open the config file and map it into our address space, then parse it.  */
 static int
 conf_load_file(const char *conf_file)
@@ -609,18 +637,129 @@ conf_load_file(const char *conf_file)
 	return 0;
 }
 
+static void 
+conf_init_dir(const char *conf_file)
+{
+	struct dirent **namelist = NULL;
+	char *dname, fname[PATH_MAX], *cname;
+	int n = 0, nfiles = 0, i, fname_len, dname_len;
+	int trans, rv, path_len;
+
+	dname = malloc(strlen(conf_file) + 3);
+	if (dname == NULL) {
+		xlog(L_WARNING, "conf_init_dir: malloc: %s", strerror(errno));
+		return;	
+	}
+	sprintf(dname, "%s.d", conf_file);
+
+	n = scandir(dname, &namelist, NULL, versionsort);
+	if (n < 0) {
+		if (errno != ENOENT) {
+			xlog(L_WARNING, "conf_init_dir: scandir %s: %s", 
+				dname, strerror(errno));
+		}
+		free(dname);
+		return;
+	} else if (n == 0) {
+		free(dname);
+		return;
+	}
+
+	trans = conf_begin();
+	dname_len = strlen(dname);
+	for (i = 0; i < n; i++ ) {
+		struct dirent *d = namelist[i];
+
+	 	switch (d->d_type) {
+			case DT_UNKNOWN:
+			case DT_REG:
+			case DT_LNK:
+				break;
+			default:
+				continue;
+		}
+		if (*d->d_name == '.')
+			continue;
+		
+		fname_len = strlen(d->d_name);
+		path_len = (fname_len + dname_len);
+		if (!fname_len || path_len > PATH_MAX) {
+			xlog(L_WARNING, "conf_init_dir: Too long file name: %s in %s", 
+				d->d_name, dname);
+			continue; 
+		}
+
+		/*
+		 * Check the naming of the file. Only process files
+		 * that end with CONF_FILE_EXT
+		 */
+		if (fname_len <= CONF_FILE_EXT_LEN) {
+			xlog(D_GENERAL, "conf_init_dir: %s: name too short", 
+				d->d_name);
+			continue;
+		}
+		cname = (d->d_name + (fname_len - CONF_FILE_EXT_LEN));
+		if (strcmp(cname, CONF_FILE_EXT) != 0) {
+			xlog(D_GENERAL, "conf_init_dir: %s: invalid file extension", 
+				d->d_name);
+			continue;
+		}
+
+		rv = snprintf(fname, PATH_MAX, "%s/%s", dname, d->d_name);
+		if (rv < path_len) {
+			xlog(L_WARNING, "conf_init_dir: file name: %s/%s too short", 
+				d->d_name, dname);
+			continue;
+		}
+
+		if (conf_load_files(trans, fname))
+			continue;
+		nfiles++;
+	}
+
+	if (nfiles) {
+		/* Apply the configuration values */
+		conf_end(trans, 1);
+	}
+	for (i = 0; i < n; i++)
+		free(namelist[i]);
+	free(namelist);
+	free(dname);
+	
+	return;
+}
+
 int
 conf_init_file(const char *conf_file)
 {
 	unsigned int i;
+	int ret;
 
 	for (i = 0; i < sizeof conf_bindings / sizeof conf_bindings[0]; i++)
 		LIST_INIT (&conf_bindings[i]);
 
 	TAILQ_INIT (&conf_trans_queue);
 
-	if (conf_file == NULL) conf_file=NFS_CONFFILE;
-	return conf_load_file(conf_file);
+	if (conf_file == NULL) 
+		conf_file=NFS_CONFFILE;
+
+	/*
+	 * First parse the give config file 
+	 * then parse the config.conf.d directory 
+	 * (if it exists)
+	 *
+	 */
+	ret = conf_load_file(conf_file);
+
+	/*
+	 * When the same variable is set in both files
+	 * the conf.d file will override the config file.
+	 * This allows automated admin systems to
+	 * have the final say.
+	 */
+	conf_init_dir(conf_file);
+
+	return ret;
 }
 
 /*
diff --git a/systemd/nfs-v4client.target b/systemd/nfs-v4client.target
new file mode 100644
index 0000000..3d1064e
--- /dev/null
+++ b/systemd/nfs-v4client.target
@@ -0,0 +1,12 @@
+[Unit]
+Description=NFS client services
+Before=remote-fs-pre.target
+Wants=remote-fs-pre.target
+
+# GSS services dependencies and ordering
+Wants=auth-rpcgss-module.service
+After=rpc-gssd.service rpc-svcgssd.service gssproxy.service
+
+[Install]
+WantedBy=multi-user.target
+WantedBy=remote-fs.target
diff --git a/systemd/nfs.conf.man b/systemd/nfs.conf.man
index 3f1c726..16e0ec4 100644
--- a/systemd/nfs.conf.man
+++ b/systemd/nfs.conf.man
@@ -265,7 +265,15 @@ Only
 is recognized.
 
 .SH FILES
+.TP 10n
 .I /etc/nfs.conf
+Default NFS client configuration file
+.TP 10n
+.I /etc/nfs.conf.d
+When this directory exists and files ending 
+with ".conf" exist, those files will be
+used to set configuration variables. These
+files will override variables set in /etc/nfs.conf
 .SH SEE ALSO
 .BR nfsdcltrack (8),
 .BR rpc.nfsd (8),
diff --git a/tools/mountstats/mountstats.py b/tools/mountstats/mountstats.py
index 25e92a1..23876fc 100755
--- a/tools/mountstats/mountstats.py
+++ b/tools/mountstats/mountstats.py
@@ -378,7 +378,10 @@ class DeviceData:
                 print('\t%12s: %s' % (op, " ".join(str(x) for x in self.__rpc_data[op])))
         elif vers == '4':
             for op in Nfsv4ops:
-                print('\t%12s: %s' % (op, " ".join(str(x) for x in self.__rpc_data[op])))
+                try:
+                    print('\t%12s: %s' % (op, " ".join(str(x) for x in self.__rpc_data[op])))
+                except KeyError:
+                    continue
         else:
             print('\tnot implemented for version %d' % vers)
         print()
diff --git a/utils/exportfs/exportfs.c b/utils/exportfs/exportfs.c
index 9d5e575..9fcae0b 100644
--- a/utils/exportfs/exportfs.c
+++ b/utils/exportfs/exportfs.c
@@ -176,10 +176,10 @@ main(int argc, char **argv)
 		xlog(L_ERROR, "-r and -u are incompatible");
 		return 1;
 	}
-printf("point 1\n");
+
 	if (!setup_state_path_names(progname, ETAB, ETABTMP, ETABLCK, &etab))
 		return 1;
-printf("point 2\n");
+
 	if (optind == argc && ! f_all) {
 		if (force_flush) {
 			cache_flush(1);
@@ -193,7 +193,6 @@ printf("point 2\n");
 			return 0;
 		}
 	}
-printf("point 3\n");
 
 	/*
 	 * Serialize things as best we can
diff --git a/utils/mount/nfsmount.conf.man b/utils/mount/nfsmount.conf.man
index 3aa3456..4f8f351 100644
--- a/utils/mount/nfsmount.conf.man
+++ b/utils/mount/nfsmount.conf.man
@@ -88,6 +88,13 @@ the background (i.e. done asynchronously).
 .TP 10n
 .I /etc/nfsmount.conf
 Default NFS mount configuration file
+.TP 10n
+.I /etc/nfsmount.conf.d
+When this directory exists and files ending 
+with ".conf" exist, those files will be
+used to set configuration variables. These
+files will override variables set 
+in /etc/nfsmount.conf
 .PD
 .SH SEE ALSO
 .BR nfs (5),
